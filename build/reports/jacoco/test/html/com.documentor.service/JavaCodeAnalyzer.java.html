<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JavaCodeAnalyzer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">documentor</a> &gt; <a href="index.source.html" class="el_package">com.documentor.service</a> &gt; <span class="el_source">JavaCodeAnalyzer.java</span></div><h1>JavaCodeAnalyzer.java</h1><pre class="source lang-java linenums">package com.documentor.service;

import com.documentor.config.DocumentorConfig;
import com.documentor.model.CodeElement;
import com.documentor.model.CodeElementType;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.EnumDeclaration;
import com.github.javaparser.ast.body.FieldDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

/**
 * ‚òï Java Code Analyzer
 * 
 * Parses Java source files using JavaParser to extract:
 * - Public/protected classes and interfaces
 * - Public/protected methods with signatures
 * - Public/protected fields and variables
 */
@Component
public class JavaCodeAnalyzer {

<span class="fc" id="L34">    private static final Logger logger = LoggerFactory.getLogger(JavaCodeAnalyzer.class);</span>

    private final DocumentorConfig config;
    private final JavaParser javaParser;

<span class="fc" id="L39">    public JavaCodeAnalyzer(DocumentorConfig config) {</span>
<span class="fc" id="L40">        this.config = config;</span>
<span class="fc" id="L41">        this.javaParser = new JavaParser();</span>
<span class="fc" id="L42">    }</span>

    /**
     * üìÑ Analyzes a Java file and extracts all non-private code elements
     * 
     * @param filePath Path to the Java source file
     * @return List of discovered code elements
     */
    public List&lt;CodeElement&gt; analyzeFile(Path filePath) throws IOException {
<span class="fc" id="L51">        logger.debug(&quot;üîç Analyzing Java file: {}&quot;, filePath);</span>

<span class="fc" id="L53">        String sourceCode = Files.readString(filePath);</span>
<span class="fc" id="L54">        List&lt;CodeElement&gt; elements = new ArrayList&lt;&gt;();</span>

        try {
<span class="fc" id="L57">            CompilationUnit cu = javaParser.parse(sourceCode).getResult()</span>
<span class="pc" id="L58">                    .orElseThrow(() -&gt; new IOException(&quot;Failed to parse Java file&quot;));</span>

<span class="fc" id="L60">            JavaElementVisitor visitor = new JavaElementVisitor(filePath, elements);</span>
<span class="fc" id="L61">            visitor.visit(cu, null);</span>

<span class="fc" id="L63">            logger.debug(&quot;‚úÖ Found {} elements in {}&quot;, elements.size(), filePath.getFileName());</span>
<span class="fc" id="L64">            return elements;</span>

<span class="nc" id="L66">        } catch (Exception e) {</span>
<span class="nc" id="L67">            logger.error(&quot;‚ùå Error parsing Java file {}: {}&quot;, filePath, e.getMessage());</span>
<span class="nc" id="L68">            throw new IOException(&quot;Failed to analyze Java file&quot;, e);</span>
        }
    }

    /**
     * üö∂ AST Visitor for extracting Java code elements
     */
    private class JavaElementVisitor extends VoidVisitorAdapter&lt;Void&gt; {
        
        private final Path filePath;
        private final List&lt;CodeElement&gt; elements;

<span class="fc" id="L80">        public JavaElementVisitor(Path filePath, List&lt;CodeElement&gt; elements) {</span>
<span class="fc" id="L81">            this.filePath = filePath;</span>
<span class="fc" id="L82">            this.elements = elements;</span>
<span class="fc" id="L83">        }</span>

        @Override
        public void visit(ClassOrInterfaceDeclaration declaration, Void arg) {
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">            if (shouldInclude(declaration.getModifiers())) {</span>
<span class="fc" id="L88">                String name = declaration.getNameAsString();</span>
<span class="fc" id="L89">                String qualifiedName = declaration.getFullyQualifiedName().orElse(name);</span>
                
<span class="fc" id="L91">                CodeElement classElement = new CodeElement(</span>
                    CodeElementType.CLASS,
                    name,
                    qualifiedName,
<span class="fc" id="L95">                    filePath.toString(),</span>
<span class="fc" id="L96">                    declaration.getBegin().map(pos -&gt; pos.line).orElse(0),</span>
<span class="fc" id="L97">                    extractSignature(declaration),</span>
<span class="fc" id="L98">                    extractJavadoc(declaration),</span>
<span class="fc" id="L99">                    List.of(), // Parameters for classes are empty</span>
<span class="fc" id="L100">                    extractAnnotations(declaration)</span>
                );
                
<span class="fc" id="L103">                elements.add(classElement);</span>
<span class="fc" id="L104">                logger.debug(&quot;üì¶ Found class: {}&quot;, qualifiedName);</span>
            }

<span class="fc" id="L107">            super.visit(declaration, arg);</span>
<span class="fc" id="L108">        }</span>

        @Override
        public void visit(EnumDeclaration declaration, Void arg) {
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            if (shouldInclude(declaration.getModifiers())) {</span>
<span class="fc" id="L113">                String name = declaration.getNameAsString();</span>
<span class="fc" id="L114">                String qualifiedName = declaration.getFullyQualifiedName().orElse(name);</span>
                
<span class="fc" id="L116">                CodeElement enumElement = new CodeElement(</span>
                    CodeElementType.CLASS, // Enums are treated as CLASS type
                    name,
                    qualifiedName,
<span class="fc" id="L120">                    filePath.toString(),</span>
<span class="fc" id="L121">                    declaration.getBegin().map(pos -&gt; pos.line).orElse(0),</span>
<span class="fc" id="L122">                    extractSignature(declaration),</span>
<span class="fc" id="L123">                    extractJavadoc(declaration),</span>
<span class="fc" id="L124">                    List.of(), // Parameters for enums are empty</span>
<span class="fc" id="L125">                    extractAnnotations(declaration)</span>
                );
                
<span class="fc" id="L128">                elements.add(enumElement);</span>
<span class="fc" id="L129">                logger.debug(&quot;üì¶ Found enum: {}&quot;, qualifiedName);</span>
            }

<span class="fc" id="L132">            super.visit(declaration, arg);</span>
<span class="fc" id="L133">        }</span>

        @Override
        public void visit(MethodDeclaration declaration, Void arg) {
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (shouldInclude(declaration.getModifiers())) {</span>
<span class="fc" id="L138">                String name = declaration.getNameAsString();</span>
<span class="fc" id="L139">                String signature = declaration.getDeclarationAsString(false, false, false);</span>
                
<span class="fc" id="L141">                CodeElement methodElement = new CodeElement(</span>
                    CodeElementType.METHOD,
                    name,
                    signature,
<span class="fc" id="L145">                    filePath.toString(),</span>
<span class="fc" id="L146">                    declaration.getBegin().map(pos -&gt; pos.line).orElse(0),</span>
                    signature,
<span class="fc" id="L148">                    extractJavadoc(declaration),</span>
<span class="fc" id="L149">                    extractParameters(declaration),</span>
<span class="fc" id="L150">                    extractAnnotations(declaration)</span>
                );
                
<span class="fc" id="L153">                elements.add(methodElement);</span>
<span class="fc" id="L154">                logger.debug(&quot;üîß Found method: {}&quot;, signature);</span>
            }

<span class="fc" id="L157">            super.visit(declaration, arg);</span>
<span class="fc" id="L158">        }</span>

        @Override
        public void visit(FieldDeclaration declaration, Void arg) {
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (shouldInclude(declaration.getModifiers())) {</span>
<span class="fc" id="L163">                declaration.getVariables().forEach(variable -&gt; {</span>
<span class="fc" id="L164">                    String name = variable.getNameAsString();</span>
<span class="fc" id="L165">                    String type = declaration.getElementType().asString();</span>
                    
<span class="fc" id="L167">                    CodeElement fieldElement = new CodeElement(</span>
                        CodeElementType.FIELD,
                        name,
                        type + &quot; &quot; + name,
<span class="fc" id="L171">                        filePath.toString(),</span>
<span class="fc" id="L172">                        declaration.getBegin().map(pos -&gt; pos.line).orElse(0),</span>
                        type + &quot; &quot; + name,
<span class="fc" id="L174">                        extractJavadoc(declaration),</span>
<span class="fc" id="L175">                        List.of(),</span>
<span class="fc" id="L176">                        extractAnnotations(declaration)</span>
                    );
                    
<span class="fc" id="L179">                    elements.add(fieldElement);</span>
<span class="fc" id="L180">                    logger.debug(&quot;üìä Found field: {} {}&quot;, type, name);</span>
<span class="fc" id="L181">                });</span>
            }

<span class="fc" id="L184">            super.visit(declaration, arg);</span>
<span class="fc" id="L185">        }</span>

        private boolean shouldInclude(com.github.javaparser.ast.NodeList&lt;com.github.javaparser.ast.Modifier&gt; modifiers) {
<span class="fc" id="L188">            boolean isPrivate = modifiers.stream()</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                    .anyMatch(mod -&gt; mod.getKeyword() == com.github.javaparser.ast.Modifier.Keyword.PRIVATE);</span>
            
<span class="fc bfc" id="L191" title="All 4 branches covered.">            return config.analysisSettings().includePrivateMembers() || !isPrivate;</span>
        }

        private String extractSignature(Object declaration) {
<span class="fc" id="L195">            return declaration.toString().split(&quot;\\{&quot;)[0].trim();</span>
        }

        private String extractJavadoc(Object declaration) {
            // JavaParser provides access to Javadoc comments
            // This is a simplified implementation
<span class="fc" id="L201">            return &quot;&quot;;</span>
        }

        private List&lt;String&gt; extractParameters(MethodDeclaration declaration) {
<span class="fc" id="L205">            return declaration.getParameters().stream()</span>
<span class="fc" id="L206">                    .map(param -&gt; param.getType() + &quot; &quot; + param.getName())</span>
<span class="fc" id="L207">                    .toList();</span>
        }

        private List&lt;String&gt; extractAnnotations(Object declaration) {
            // Extract annotations from the declaration
            // This is a simplified implementation
<span class="fc" id="L213">            return List.of();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>